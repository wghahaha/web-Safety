### 文件上传漏洞寻找思路（师承小迪）

个人笔记

#### 第一步收集信息

首先我们可以通过观察数据包，分析中间。主要关注的是，该网站用的是什么中间件 (Apache   Nginx   IIS  之类的)，然后就是中间件的版本号。（这一步很重要,）

### 第二步寻找上传点

接下来，我们需要的就是找到网站可以上传文件的位置。可以用扫描器扫描，也可以自己寻找，比如：会员中心之类的位置。好多就可以上传修改头像。（尽可能的找到更多的地方，这样测试范围也就更大）

#### **第三步前后端安全测试**

找到上传文件的位置后，就可以开始我们的安全测试。

我们可以根据分父类，子类的方法进行测试。

大体可以划分为前端和后端。

首先就是对于前端的测试（一般都不是），对于前端来说，方法只有==JavaScript==验证的一种方法。难度最低。

前面的失败后。就开始对于后端进行测试。

在后端的测试中，又可以划分为几个小类。

==黑名单==      ==白名单==    ==文件内容（文件头，二次渲染等）及其他（函数）==

##### 3.1黑名单

黑名单的绕过相对于白名单的绕过相对来说容易一点。

###### 3.1.1特殊解析后缀

比如有些程序员，他在后端对于文件后缀进行了黑名单验证的操作，但是他没有完全的过滤。

比如 禁止 ==php==  后缀上传，但是我们可以通过 ==php5==  ==phtml==绕过。

###### 3.1.2上传`.htaccess`

.htaccess文件(或者"分布式配置文件"）提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。

这就是我们在第一步就要看中间件是什么的原因。如果中间件不是==Apache==那么就无法利用这个了。

###### 3.1.3 上传`.user.ini`

这个的使用要求和上面的一样比较特殊，需要服务器脚本是php源码，并且使用**CGI/FastCGI**模式，php版本>5.3.0

原理：

`.user.ini`，它会影响`php.ini`中的配置，从而将指定的文件内容按php来解析，影响的范围该文件所在的目录以及子目录。需要等待`php.ini`中的`user_ini.cache_ttl`设置的时间或重启Apache才能生效，且只在php5.3.0之后的版本才生效。`.user.ini`比`.htaccess`用的更广，不管是`nginx/Apache/IIS`,只要是以`fastcgi`运行的php都可以用这个办法。如果使用Apache，则用`.htaccess`文件有同样的效果。

###### 3.1.4大小写绕过

这个和前面的 **3.1.1**，我感觉很类似。但是小迪老师将这个单独分为一类，我也将这个分出来。

比如开发者，对后端的==phtml== ==php== ==php5== 这些都进行过滤，我们要上传==php==文件，还可以使用 ==PHp== ==Php== 以及 ==PHp5==这些进行绕过，因为他们同样可以被解析为 php文件，发生这个的原因主要是 程序员对进行后缀过滤的代码当中没有使用 ==strtolower()函数。==

==strtolower() 函数==把字符串转换为小写。

###### 3.1.5点绕过

这种利用的是操作系统的特性。在末尾有点的可以直接被忽略。但是在后端代码当中，并没有将其忽略掉。

注意：需要在服务器是windows时使用。

###### 3.1.6空格绕过

和上面的一样如果服务器时windows平台的情况下，后缀名最后一个是空格，还是会直接被忽略掉。

**补充：利用操作系统特性-Windows**

利用Windows对于文件和文件名的限制，以下字符放在结尾时，不符合操作系统的命名规范，在最后生成文件时，字符会被自动去除。

|    上传文件名     | 服务器文件名 |                             说明                             |
| :---------------: | :----------: | :----------------------------------------------------------: |
|  file.php[空格]   |   file.php   |                                                              |
|    file.php[.]    |   file.php   |                      无论多少个.都可以                       |
| file.php[%80-%99] |   file.php   | Burp抓包，在文件名结尾输%80，CTRL+SHIFT+U进行URL-DECODE,或者增加一个空格，再在HEX视图中把20修改为80 |

|      上传文件名       | 服务器生成文件名 |         内容         |
| :-------------------: | :--------------: | :------------------: |
|    file.php::$DATA    |     file.php     | file.php中的实际内容 |
| file.php::$DATA...... |     file.php     |         实际         |

###### **3.1.6:$DATA绕过**

应用场景：Windows平台，没有使用`str_ireplace()`将`::$DATA`替换为空，导致可以利用NTFS文件流特性。

利用方式：

假设xxx.php的内容为`<?php phpinfo();?>`

|        上传的文件名        |  服务器表面现象   |    生成的文件内容    |
| :------------------------: | :---------------: | :------------------: |
|       xxx.php:a.jpg        |    生成xxx.php    |          空          |
|     **xxx.php::$DATA**     |  **生成xxx.php**  | `<?php phpinfo();?>` |
| xxx.php::$INDEX_ALLOCATION | 生成xxx.php文件夹 |                      |
|     xxx.php::$DATA.jpg     |     生成0.jpg     | `<?php phpinfo();?>` |
|   xxx.php::$DATA\aaa.jpg   |    生成aaa.jpg    | `<?php phpinfo();?>` |

###### 3.1.7 配合解析漏洞

这需要结合中间件进行分析，具体方式需要去vulhub的环境进行复现然后总结。这个后面我刷了那个靶机，再单独做总结。

###### 3.1.8 双后缀名绕过

有些是直接将敏感的后缀去掉然后上传的。比如将==php==被替换为空，我们可以用 ==pphphp==j进行绕过。



如果到了这一步还是没有办法的，就需要考虑是白名单绕过了。（黑名单的安全性相对较低，现在很多网站都是用的白名单验证了）

##### 3.2 白名单

就是只允许指定的文件后缀名上传 比如 `jpg`,`png`,`zip``gif`等

###### 3.2.1 MIME绕过

MIME多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。

**原理**

部分Web应用系统判定文件类型是通过content-type字段，黑客可以通过抓包，将content-type字段改为常见的图片类型，如==image/gif==，从而绕过校验。

常见的类型

==text/plain==（纯文本）
==text/html==（HTML文档）
==text/javascript==（js代码）
==application/xhtml+xml==（XHTML文档）
==image/gif==（GIF图像）
==image/jpeg==（JPEG图像）
==image/png==（PNG图像）
==video/mpeg==（MPEG动画）
==application/octet-stream==（二进制数据）
==application/pdf==（PDF文档）

###### 3.2.2 %00截断

这个需要的是上传的路径是可以控制的才可以

**原理**

%00是chr(0)，空字符。

程序会把%00当做结束符，后面的数据直接忽略掉。

例：

正常情况下，服务器拼接得到的上传路径为：

```
$img_path = ../upload/5920201223231032.gif;
```

而用户在可控的上传路径中，使用`%00截断`后，拼接得到的上传路径为：

```
$img_path = ../upload/xxx.php%00/5920201223231032.gif
```

对后缀进行白名单检测，为gif。但是保存在服务器上的文件，却是`xxx.php`，因为%00之后的内容被截断了。

###### 3.2.3 ==0x00==截断

这个需要php版本<5.3.4而且将php.ini中的`magic_quotes_gpc`设置为off、上传路径可控

原理和上面的类似。

例：

如果上传文件的路径为：用户可控的上传路径/随机数.白名单中的后缀

正常情况下，服务器拼接得到的上传图像地址为`$img_path =../upload/5920201223231032.gif`

但是，用户如果在可控上传路径中写入一个php后缀，并且php后缀后面有一个`0x00`字符

服务器拼接得到的上传图像地址会变为`$img_path =../upload/xxx.php[0x00]/5920201223231032.gif`

对后缀进行白名单检测，为gif。但是保存在服务器上的文件，却是`xxx.php`，因为`0x00`之后的内容被截断了。

###### 3.2.4  ==0x0a==截断

原理和上面的类似

利用的思路也可以直接参考上面的。

到了这里还是没法成功的话，就往下面走吧

##### 3.3  内容及其他

###### 3.3.1 文件头检测

有些会对文件头的内容进行检测，如果不合法的话，也会被直接==pass==掉。这个时候只需要将 文件头改为合法的就可以了。

上传具有正常文件头的图片马即可。

```
gif`的文件头为`GIF89a`；`png`的文件头为`89504E47`；`jpg`的文件头为`FFD8FF
```

###### 3.3.2 二次渲染

在我们上传文件后，网站会对图片进行二次处理（格式、尺寸要求等），处理后在放到网站对应的标签进行显示。

这里需要绕过的方法可以自己找到 ==hex== 没有改变的地方。然后插入代码。

不同的文件类型的处理情况是不一样的，比如 gif 文件 他的 hex 没有修改的地方，相对于好找，就可以使用上面的方法。

但是如果是==png==格式的文件的情况下，上面的方法就不适用了。

png：写入IDAT数据块

使用脚本生成图片马

下面这个是转载别人写的脚本，我还没有能力写出来。

```php
<?php
$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23,
         0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae,
         0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc,
         0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f,
         0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c,
         0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d,
         0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1,
         0x66, 0x44, 0x50, 0x33);
$img = imagecreatetruecolor(32, 32);
for ($y = 0; $y < sizeof($p); $y += 3) {
 $r = $p[$y];
 $g = $p[$y+1];
 $b = $p[$y+2];
 $color = imagecolorallocate($img, $r, $g, $b);
 imagesetpixel($img, round($y / 3), 0, $color);
}
imagepng($img,'./idat.png');
?>

```

###### 3.3.3 条件竞争

官方解释 ： 发生在多个线程同时访问同一个共享代码、变量、文件等没有进行锁操作或者同步操作的场景中。

简单的来说，在windows操作系统中，我们如果打开一个文本文件（其他文件也可以），然后我们在没有将其关闭的情况下，将这个文件进行删除，系统就会报错。

在文件上传靶场中有两关可以用这个方法做。

他写的代码逻辑就是 先将这个文件上传到服务器当中，然后再对文件内容进行检测，如果文件合法的话就对于文件重新命名。如果不合法的话就删除文件。

这种代码逻辑的存在问题的，如果我们用==burp==不停的向服务器发送相同的文件。然后我们在浏览器上不停的访问。或者写个==python==脚本。当访问的时候正好在进行删除操作，那么就会发生条件竞争。然后我们在上传的文件中插入文件包含漏洞，然后再再进行文件上传漏洞。

###### 3.3.4 突破`getimagesize()`

getimagesize() 函数用于获取图像大小及相关信息，成功返回一个数组，失败则返回 FALSE 并产生一条 E_WARNING 级的错误信息。

`getimagesize()`函数会返回一个数组，其中下标2是图像的类型。1=GIF，2=JPG, 3=PNG。这里上传一个正常图像后缀的图片马，使用文件包含漏洞运行图片马中的恶意代码即可。

###### 3.3.5 突破`exif_imagetype()`

PHP手册 https://www.php.net/manual/zh/function.exif-imagetype.php

利用

`exif_imagetype()`— 判断一个图像的类型。检查图像的第一个字节。可能返回的常量有`IMAGETYPE_GIF=1`；`IMAGETYPE_JPEG=2`;`MAGETYPE_PNG=3`;文件头不正确返回false。

上传具有正常文件头的图片马即可。

`gif`的文件头为`GIF89a`；`png`的文件头为`89504E47`；`jpg`的文件头为`FFD8FF`。然后使用文件包含漏洞运行图片马中的恶意代码。

#### 阶段性总结：

前面的情况大多都是基于自主分析的类型。有代码层面的。也有中间件层面的。但是在实战中，我们总会遇到一些奇奇怪怪的情况。我们也不可能将所有的方法全部掌握（因为是掌握不完的）文件上传的绕过方法远远不至于上面的几种。这个时候我们需要到互联网去根据我们自己的需要去寻找资源，主要查的是在基于你当前的情况下，被曝出了有哪些漏洞。比如 很多网站用的是CMS搭建的，我们可以去寻找对应版本下的CMS出现了哪些漏洞，然后我们再尝试复现。下面会提到。

#### 第四步，网络查询安全测试

##### 4.1 解析漏洞

主要是关于几个中间件是否还存在解析漏洞，前面有提过。

##### 4.2 CMS漏洞

很多搭建网站都是用的网上的CMS（WordPress,PHPcms之类的）搭建的，那么如果这个CMS爆出过漏洞，但是网站管理员没有及时的进行更新，我们就可以利用这个机会。

网上肯定也会有这种复现过程，直接照着复现就可以了

##### 4.3 其他漏洞

###### 4.3.1 编辑器漏洞

在我们的网站后台编辑内容的一个小系统，被称为编辑器。这里本来不算文件上柴漏洞的范围，但是由于编辑器很多都是文件上传漏洞，所以还是把这个部分加上了。

复现方法：

首先我们想办法知道编辑器的版本号，类型之类的基本信息。比如：fckeditor ckeditor 之类的。

当我们知道基础信息后然后到网上去找有没有相应的漏洞。有的话根据网上的教程进行复现，看是否可以复现成功。

###### 4.3.2 CVE

前面的都试过了以后，我们去网上查一下最近的CVE漏洞，有没有是关于文件上传方面的，如果有的话，再看看我们的目标网站，和查找的CVE漏洞有没有相符的。再进行尝试。

这就是关于文件上传漏洞的思路，有很多地方是在其他漏洞也是通用的。其实在这个过程中，最关键的还是关于信息的挖掘，只有挖掘到了更多的信息，才可以进行更加全面的安全测试。

渗透测试的本质就是信息收集。哈哈哈哈哈





























